<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Análise</title>
</head>
	
<body>
	<h1>Selection Sort</h1>
	
	<p>
	<ul>
	  <li> ●Seleciona o menor e coloca na primeira posição.
	  
	  <li> ●Não estável: NÃO preserva ordem dos elementos iguais.
	  In-place: feita no próprio array. Não utiliza memória auxiliar proporcional a n
	  Eficiência (N^2).
	  
	  <li> ●Número de comparações: (n-1) + (n-2) + (n-3) + ...3 + 2 + 1 + 0.
	  PA decrescente finita.
	  
	  <li> ●Número de trocas: n
	<ul>
	</p>
	  
	<p>
	  in-place porque a ordenação é feita rearranjando os elementos no próprio array, 
	  ao invés de usar arrays ou outras estruturas auxiliares.
	</p>
	  
	<p>
	  Conceito de Estabilidade:
	  O Selection Sort não é estável porque dependendo das trocas, ele não mantém a ordem relativa dos valores iguais. 
	  Vamos analisar um exemplo em que isso acontece. Para diferenciar valores iguais, vou colocar os subscritos a e b:
		
	  values=[1,7a,7b,2]
	  Na primeira iteração, o menor valor é 1 e, por isso, fica na posição em que está. 
	  Depois, na segunda iteração o menor valor é 2 e deve trocar de lugar com 7a. O resultado parcial é:
	  values=[1,2,7b,7a]
	</p>
	  
    <p>
    <u>
	  Relação com Insertion Sort:
		  <li> Selection Sort efetua menos troca do que Insertion, pois há uma troca apenas por iteração.</li>
		  <li> O Insertion executa ao menos uma troca por iteração.</li>
		  <li> Por outro lado, o Insertion Sort efetua menos comparações do que o Selection Sort, 
		  	   pois nem sempre o elemento a ser inserido de forma ordenada deve ir até o final.
		  	   Na verdade, isso só acontece no pior dos casos, em que o array está ordenado em ordem reversa. </li>
		  <li> Já o Selection Sort precisa comparar todos os elementos restante cada vez para determinar quem é o menor deles.</li>
	</u>
	 </p>
	 
	 <h2>Análise sobre o compareTo</h2>
	 <p>O trecho array[j].compareTo(array[indiceMenor]) < 0 é uma comparação que é realizada entre dois elementos de um array, 
	  onde array é o nome do array e j e indiceMenor são índices do array que indicam as posições dos elementos que serão comparados.</p>
	  
	 <p>Aqui, está sendo utilizado o método compareTo, que é utilizado para comparar dois objetos que implementam a interface Comparable. 
	  Esse método retorna um valor inteiro que indica se um objeto é maior, menor ou igual ao outro objeto.</p>
	  
	 <p>O valor de retorno do método compareTo é um número negativo se o objeto que chama o método for menor do que o objeto passado como parâmetro. 
	  Se o valor de retorno for zero, significa que os objetos são iguais. Por outro lado, se o valor de retorno for positivo, 
	  significa que o objeto que chama o método é maior do que o objeto passado como parâmetro.</p>
	  
	 <p>No trecho de código que você apresentou, array[j].compareTo(array[indiceMenor]) < 0 é utilizado para verificar se o elemento na posição j do array
	  é menor do que o elemento na posição indiceMenor do array. Se a condição for verdadeira, o índice do menor elemento é atualizado para j.</p>
	   
	 <p>Essa comparação é realizada dentro de um laço que percorre o array da posição i+1 até a posição rightIndex. Ou seja, esse laço busca o menor elemento
	  dentro do intervalo do array que começa em i+1 e termina em rightIndex. O menor elemento encontrado nesse intervalo será armazenado na variável indiceMenor.</p>
	
	 <p>Ao final do laço, a função swap é chamada para trocar a posição do menor elemento encontrado com a posição i do array. Dessa forma, ao final do laço, 
	  o menor elemento dentro do intervalo leftIndex e rightIndex do array estará na posição i do array.<p>
	  
	  <h1>Resumo</h1>
	  <p>
	  <ul>
	  <li>● O Selection Sort segue uma rotina bem simples e direta: encontrar o menor elemento e colocá-lo na primeira posição. 
	  A ordenação nada mais é do que aplicar essa rotina repetidas vezes para o restante do array;</li>
	  
	  <li>● O Selection sort é in-place e O(n2);</li>
	  
	  <li>● A implementação clássica do Selection Sort não é estável;</li>
	  
	  <li>● Embora sejam da mesma classe de complexidade, o Selection Sort, na prática, é mais lento do que o Insertion Sort;</li>
	  
	  <li>● O Selection Sort não é considerado um algoritmo eficiente para grandes entradas. Há alternativas O(n∗logn), 
	  como Quick Sort e Merge Sort, além de alternativas lineares como o Counting Sort.</li>
	  </ul>
	  </p>
	  
</body>
</html>